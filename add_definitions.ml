(******************************************************************************)
(*   Copyright (C) 2014-2015 THALES Communication & Security                  *)
(*   All Rights Reserved                                                      *)
(*   KTD SCIS 2014-2015                                                       *)
(*   Use Case Legacy TOSA                                                     *)
(*   author: Hugues Balp                                                      *)
(*                                                                            *)
(* This file completes the function's declarations generated by Callers with "definitions" members *)
(* It is issued from a copy/paste from the add_declarations.ml OCAML backend *)
(* The high-level specification of this backend can be formalized as follows: *)
(* V fct_def, ] fct_decl / fct_def.decl = fct_decl *)
(* with V = whatever & ] = there is *)
(* WARNING: several definitions can be found for the same declaration *)
(*  even if only one is tolerated during link edition *)
(* This is required to handle the general case where the same header *)
(* can be reused by different applications and build systems. *)
(******************************************************************************)

exception Internal_Error
(* exception Unexpected_Case *)
exception Usage_Error
exception File_Not_Found
exception Symbol_Not_Found
exception TBC
exception Unexpected_Error
(* exception Missing_File_Path *)
exception Malformed_Definition_Declaration

(* module Definition = Map.Make(String);; *)

type definitions = Definition of string list;;

class function_definition_json_parser (callee_json_filepath:string) = object(self)

  val callee_file_path : string = callee_json_filepath

  method read_json_file (filename:string) : Yojson.Basic.json option =
    try
      Printf.printf "In_channel read file %s...\n" filename;
      (* Read JSON file into an OCaml string *)
      let buf = Core.Std.In_channel.read_all filename in
      if ( String.length buf != 0 ) then
	(* Use the string JSON constructor *)
	let json = Yojson.Basic.from_string buf in
	Some json
      else
	None
    with
      Sys_error _ -> 
	(
	  Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
	  Printf.printf "add_definitions::ERROR::File_Not_Found::%s\n" filename;
	  let bname = Filename.basename filename in
	  (match bname with
	  | "defined_symbols.dir.callers.gen.json" ->
	    Printf.printf "You need first to list all the defined symbols by executing the list_json_files_in_dirs ocaml program\n"
	  | _ -> 
	    Printf.printf "You need first to generates all the json files by running the clang Callers's plugin\n"	    
	  );
	  Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
	  raise File_Not_Found
	)

  method search_symbol_in_directories (fct_sign:string) (dir:Callgraph_t.dir) (dirfullpath:string) : (string * int) option =

    Printf.printf "Parse dir: %s\n" dirfullpath;
    Printf.printf "================================================================================\n";

    let defined_symbols_filename : string = "defined_symbols.dir.callers.gen.json" in

    let defined_symbols_filepath : string = Printf.sprintf "%s/%s" dirfullpath defined_symbols_filename in

    Printf.printf "Read symbols defined in dir: %s\n" dirfullpath;

    let dir_symbols : Callgraph_t.dir_symbols option = self#read_defined_symbols_in_dir defined_symbols_filepath in

    let searched_symbol : (string * int) option = 
      (
	match dir_symbols with
	| None -> None
	| Some dir_symbols ->
	  self#search_symbol_in_dir fct_sign dir_symbols
      )
    in

    (match searched_symbol with

    | None -> (* Not yet found symbol, so we look for it in childrens directories *)
      (
	Printf.printf "Not found symbol \"%s\" in directory \"%s\", so we look for it in childrens directories" fct_sign dirfullpath;
	
	let searched_symbol : (string * int) option = 
	  (match dir.childrens with
	  | None -> None
	  | Some subdirs -> 

	    let searched_symbols : (string * int) option list = 
	      List.map
		(
		  fun (d:Callgraph_t.dir) -> 
		    let dirpath : string = Printf.sprintf "%s/%s" dirfullpath d.dir in
		    let searched_symbol = self#search_symbol_in_directories fct_sign d dirpath in
		    searched_symbol
		)
		subdirs
	    in
	    let searched_symbol : (string * int) option = self#filter_found_symbol searched_symbols in
	    searched_symbol
	  )
	in
	searched_symbol
      )

    | Some found_symbol -> 
      (
	Printf.printf "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n";
	Printf.printf "FOUND symbol \"%s\" in directory \"%s\" !\n" fct_sign dirfullpath;
	Printf.printf "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n";
	searched_symbol
      )
    )

  (** Reads the symbols defined in input directory *)
  method read_defined_symbols_in_dir (defined_symbols_jsonfilepath:string) : Callgraph_t.dir_symbols option =

    let read_json : Yojson.Basic.json option = self#read_json_file defined_symbols_jsonfilepath in
    (match read_json with
    | None -> None
    | Some json -> 
      (
	let content : string = Yojson.Basic.to_string json in
	Printf.printf "Reads the symbols defined in file \"%s\"\n" defined_symbols_jsonfilepath;
	(* Printf.printf "HBDBG parsed content:\n %s: \n" content; *)
	Printf.printf "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n";
	(* list_defined_symbols content root_dir_fullpath all_symbols_jsonfile application_name *)
	let dir_symbols : Callgraph_t.dir_symbols = Callgraph_j.dir_symbols_of_string content in
	(* print_endline (Callgraph_j.string_of_dir_symbols dir_symbols); *)
	Some dir_symbols
      )
    )

  (** Return the location of the function declaration when defined in one of the searched directories *)
  method search_declared_symbol (fct_sign:string) (root_dir_fullpath:string) (searched_dirs_fullpaths:string) : (string * int) option =

    Printf.printf "Return the location of function \"%s\" when found within root directory: \"%s\" or within other searched directories: \"%s\"\n" fct_sign root_dir_fullpath searched_dirs_fullpaths;

    let searched_directories_fullpaths : string list = Str.split_delim (Str.regexp ":") searched_dirs_fullpaths in
    let all_directories_fullpaths : string list = root_dir_fullpath::searched_directories_fullpaths in

    let search_results : (string * int) option list  = 
      List.map
	( 
	  fun searched_dir_fullpath ->
	    
	  (* Use the atdgen Yojson parser to parse the input directory tree json file *)
	  let jsondirext : string = "dir.callers.gen.json" in
	  let searched_dir_name : string = Filename.basename searched_dir_fullpath in
	  let searched_dir_jsoname : string = Printf.sprintf "%s/%s.%s" searched_dir_fullpath searched_dir_name jsondirext in
	  let searched_dir_json : Yojson.Basic.json option = self#read_json_file searched_dir_jsoname in
	      
	  (match searched_dir_json with
	   | None -> None
	   | Some searched_dir_json ->
	      (
		let searched_dir_content : string = Yojson.Basic.to_string searched_dir_json in
		let searched_dir_tree : Callgraph_t.dir = Callgraph_j.dir_of_string searched_dir_content in
		(* print_endline (Callgraph_j.string_of_dir searched_dir_tree); *)
		    
		(* Look for the symbol in all directories recursively. *)
		self#search_symbol_in_directories fct_sign searched_dir_tree searched_dir_fullpath
	      )
	  )
	)
	all_directories_fullpaths
    in

    let found_symbol : (string * int) option = 
      try
	(
	  List.find
	    ( fun result ->
	      (
		match result with
		| None -> false
		| Some (symb_def_file, symb_def_line) ->
		   (
		     Printf.printf "add_definitions.ml: INFO::FOUND declaration of function \"%s\" in \"%s:%d\"\n" fct_sign symb_def_file symb_def_line;
		     true
		   )
	      )
	    )
	    search_results
	)
      with
	Not_found -> 
	(
	  Printf.printf "add_definitions.ml::WARNING::NOT FOUND symbol \"%s\" in root directory \"%s\" nor in searched directories \"%s\"\n" fct_sign root_dir_fullpath searched_dirs_fullpaths;
	  Printf.printf "The input defined symbols json file is incomplete.\n";
	  Printf.printf "The not found symbol is probably part of an external library.\n";
	  (* raise Symbol_Not_Found; *)
	  None
	)
    in
    found_symbol

  (** Return the location of the function declaration when defined in the input directory symbols table *)
  method search_symbol_in_dir (fct_sign:string) (symbols:Callgraph_t.dir_symbols) : (string * int) option =

    Printf.printf "Search for the function's declaration \"%s\" in directory \"%s\"...\n" fct_sign symbols.directory;
    (* print_endline (Callgraph_j.string_of_dir_symbols symbols); *)
    
    (* Look for the function definition among all functions defined in the json file *)
    let searched_symbols : (string * int) option list =
      List.map
      (
	fun (file : Callgraph_t.file) -> 
	  (* Check whether the function is the searched one *)
	  let searched_symbol_def : (string * int) option = 
	    try
	      (
		let searched_symbol : Callgraph_t.fct_def option = 
		  (
		    match file.defined with
		    | None -> None
		    | Some symbols ->
		      Some (
			List.find
			  (
			    fun (fct : Callgraph_t.fct_def) -> 
			    (* Printf.printf "HBDBG6: Check whether the function is the searched one: \"%s\" =?= \"%s\"\n" fct.sign fct_sign; *)
			    String.compare fct.sign fct_sign == 0
			  )
			  symbols
		      )
		  )
		in
		(match searched_symbol with
		| None -> None
		| Some found_symbol ->
		  (
		    (* Get the function declaration location *)
		    let symb_def_file : string = Printf.sprintf "%s/%s/%s" symbols.path symbols.directory file.file in
		    Printf.printf "HBDBG7 Found symbol \"%s\" in def=\"%s:%d\"\n" fct_sign symb_def_file found_symbol.line;
		    Some (symb_def_file, found_symbol.line)
		  )
		)
	      )
	    with
	      Not_found -> None
	  in
	  searched_symbol_def
      )
	symbols.file_symbols
    in
    self#filter_found_symbol searched_symbols

  method filter_found_symbol (searched_symbols : (string * int) option list) : (string * int) option =

    let searched_symbol : (string * int) option =
      try
	List.find
	  (
	    fun result ->
	      (* Check whether the function is the searched one *)
  	      (match result with
	      | None -> false
	      | Some _ -> true
	      )
	  )
	  searched_symbols
      with
	Not_found -> None
    in
    searched_symbol
      
  method print_edited_file (edited_file:Callgraph_t.file) (json_filename:string) =

    let jfile = Callgraph_j.string_of_file edited_file in
    (* print_endline jfile; *)
    (* Write the new_file serialized by atdgen to a JSON file *)
    (* let new_jsonfilepath:string = Printf.sprintf "%s.new.json" json_filename in *)
    (* Core.Std.Out_channel.write_all new_jsonfilepath jfile *)
    Core.Std.Out_channel.write_all json_filename jfile

  method parse_functions_definitions (json_filepath:string) (root_dir_fullpath:string) (searched_dirs_fullpaths:string): Callgraph_t.file option =

    (* Use the atdgen Yojson parser *)
    let dirpath : string = Common.read_before_last '/' json_filepath in
    let filename : string = Common.read_after_last '/' 1 json_filepath in
    let jsoname_file = String.concat "" [ dirpath; "/"; filename; ".file.callers.gen.json" ] in
    let read_json : Yojson.Basic.json option = self#read_json_file jsoname_file in
    (match read_json with
    | None -> None
    | Some json ->
      (
	let content : string = Yojson.Basic.to_string json in
	(* Printf.printf "Read caller file \"%s\" content is:\n %s: \n" filename content; *)
	(* Printf.printf "atdgen parsed json file is :\n"; *)
	let file : Callgraph_t.file = Callgraph_j.file_of_string content in
	(* print_endline (Callgraph_j.string_of_file file); *)
	
	(* Parse the json functions contained in the current file *)
	let edited_functions:Callgraph_t.fct_decl list =

	  (match file.declared with
	  | None -> []
	  | Some fcts ->
	    (
	      (* Parses all defined function *)
	      let edited_functions : Callgraph_t.fct_decl list =

		List.map
  		  (
  		    fun (fct:Callgraph_t.fct_decl) -> 
		    (
		      (* check where the function is really declared. *)
		      Printf.printf "Try to edit definition of function \"%s\" defined in file \"%s\"...\n" fct.sign file.file;

		      (* Check whether the definition declaration does already exists or not *)
		      let edited_definitions : definitions =
			(match fct.definitions with
			 | Some defs ->
			    (
			      (* Print any already existing definitions: *)
			      Printf.printf "ALREADY EXISTING definition(s) for declaration: sign=\"%s\", line=\"%d\"\n" fct.sign fct.line;
			      List.iter
				(
				  fun def -> Printf.printf " def=\"%s\"\n" def
				)
				defs;
			      (* Check whether the current definition does already exists or not *)
			      raise TBC;
			      Definition defs
			    )
			 | None ->
			    (
			      (* Location of definition is not yet known. *)
			      Printf.printf "No already existing definition for function implementation: sign=\"%s\", line=\"%d\", decl=?\n" fct.sign fct.line;
			      (Printf.printf "Try to look for symbol \"%s\" in the root directory \"%s\"...\n" fct.sign root_dir_fullpath;
			       let search_result : (string * int) option = self#search_declared_symbol fct.sign root_dir_fullpath searched_dirs_fullpaths
			       in
			       (match search_result with
				| Some (def_file, def_line) -> 
				   (
				     (* Check whether the declaration is local to the caller file or external. *)
				     (* Printf.printf "add_definitions.ml::INFO::Check whether the declaration is local to the caller file or external.\n"; *)
				     (* Printf.printf "symb_def_file: %s\n" def_file; *)
				     (* Printf.printf "caller_file: %s\n" json_filepath; *)
				     let definition_def : string = Printf.sprintf "%s:%d" def_file def_line in
				     let declaration_def : string = Printf.sprintf "%s:%d" file.file fct.line
				     in
				     (* Make sure the definition_def is wellformed or not *)
				     (match definition_def with
				      | "" -> raise Malformed_Definition_Declaration
				      | _ -> ());
				     if String.compare def_file json_filepath == 0 then
				       (
					 Printf.printf "add_definitions.ml::INFO::the definition is local to the declaration's file\n";
				       )
				     else
				       (
					 Printf.printf "add_definitions.ml::INFO::the definition is extern to the declaration's file, so edit its declaration: new value is \"%s\"\n" definition_def
				       );
				     let (edited_definitions : definitions) = Definition [definition_def]
				     in
				     Printf.printf "EDITED definition: sign=\"%s\", decl=\"%s\", def=\"%s\"\n" 
						   fct.sign declaration_def definition_def;
				     edited_definitions
				   )
				| None -> 
				   (
				     Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
				     Printf.printf "add_definitions.ml::WARNING::Not found symbol \"%s\" in root directory \"%s\" and other searched directories \"%s\"\n" 
						   fct.sign root_dir_fullpath searched_dirs_fullpaths;
				     Printf.printf "The not found symbol is probably part of another external library.\n";
				     Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
				     (* raise Symbol_Not_Found *)
				     let definition_def = 
				       (match fct.virtuality with
					| Some "pure" -> "none"
					| _ -> "unlinkedDefinition"
				       )
				     in
				     let declaration_def = "unlinkedDeclaration" in
				     (* Keep the input excallee unchanged *)
				     let (edited_definitions : definitions) = Definition [definition_def]
				     in
				     Printf.printf "NOT FOUND definition: sign=\"%s\", decl=%s, def=%s\n" fct.sign definition_def declaration_def;
				     edited_definitions
				   )
			       )
			      )
			    )
			)
		      in
		      let edited_definitions : string list =
			(match edited_definitions with
			   | Definition d -> 
			      List.filter
				(
				  fun (def:string) -> 
				  (
				    match def with
				     | "none" -> false
				     | _ -> true
				  )
				)
				d
			)
		      in
		      let edited_declaration : Callgraph_t.fct_decl =
			{
			  eClass = Config.get_type_fct_decl();
  			  sign = fct.sign;
  			  line = fct.line;
			  virtuality = fct.virtuality;
			  redeclarations = fct.redeclarations;
			  definitions = Some edited_definitions;
			  redefinitions = fct.redefinitions;
  			  locallers = fct.locallers;
  			  extcallers = fct.extcallers;
			}
		      in
		      edited_declaration
		    )
		  )
		  fcts
	      in
	      edited_functions
	    )
	  )
	in

	let edited_file : Callgraph_t.file = 
	  {
	    eClass = Config.get_type_file ();
	    file = file.file;
	    path = file.path;
	    namespaces = file.namespaces;
	    records = file.records;
	    declared = Some edited_functions;
	    defined = file.defined;
	  }
	in
	Some edited_file
      )
    )
end

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("file_json" %: string)
  +> anon ("root_dir_fullpath" %: string)
  +> anon (maybe_with_default "" ("searched_dirs_fullpaths" %: string))

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"Completes function declarations with definitions in generated json files"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun file_json root_dir_fullpath searched_dirs_fullpaths () -> 
	try
	  (
	    let parser = new function_definition_json_parser file_json in
	    let edited_file = parser#parse_functions_definitions file_json root_dir_fullpath searched_dirs_fullpaths in
	    (match edited_file with
	    | None -> ()
	    | Some edited_file ->
	      (
		(* let jsoname_file = String.concat "." [ file_json; "edited.debug.json" ] in *)
		let jsoname_file = String.concat "" [ file_json; ".file.callers.gen.json" ] in
		parser#print_edited_file edited_file jsoname_file
	      )
	    )
	  )
	with
	| File_Not_Found _ -> raise Usage_Error
	| _ ->
	  (
	    Printf.printf "add_definitions::ERROR::unexpected error\n";
	    raise Unexpected_Error
	  )
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -tag thread add_definitions.native" *)
(* End: *)
