(* Copyright (C) 2015 Thales Communication & Security *)
(*   - All Rights Reserved *)
(* author: Hugues Balp *)
(* This program generates a json file listing all the symbols defined in json file generated by the callers's analysis *)
(* adapted from callgraph_from_json.ml *)

exception File_Not_Found
exception Usage_Error
exception Unexpected_Json_File_Format

let read_json_file (filename:string) : Yojson.Basic.json =
  try
    Printf.printf "In_channel read file %s...\n" filename;
    (* Read JSON file into an OCaml string *)
    let buf = Core.Std.In_channel.read_all filename in           
    (* Use the string JSON constructor *)
    let json = Yojson.Basic.from_string buf in
    json
  with
  | Sys_error msg -> 
    (
      Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
      Printf.printf "list_defined_symbols::ERROR::File_Not_Found::%s\n" filename;
      Printf.printf "You need first to list all the application's directories by executing the list_json_files_in_dirs ocaml program\n";
      Printf.printf "Sys_error msg: %s\n" msg;
      Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
      raise File_Not_Found
    )
    
let parse_json_file (filename:string) (content:string) : Callgraph_t.file =

  try
    Printf.printf "atdgen parsed json file is :\n";
    (* Use the atdgen JSON parser *)
    let file : Callgraph_t.file = Callgraph_j.file_of_string content in
    print_endline (Callgraph_j.string_of_file file);
    file
  with
    Yojson.Json_error msg ->
      (
  	Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
  	Printf.printf "list_defined_symbols::ERROR::Unexpected_Json_File_Format::%s\n" filename;
  	Printf.printf "This json file is not compatible with Caller's generated json files\n";
  	Printf.printf "Sys_error msg: %s\n" msg;
  	Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
  	raise Unexpected_Json_File_Format
      )

let filter_file_content (full_file_content:Callgraph_t.file) : Callgraph_t.file = 

  let defined_symbols =
    match full_file_content.defined with
    | None -> None
    | Some symbols ->
      Some
	(
	  List.map
	    (
	      fun (fct:Callgraph_t.fct) -> 
		let defined_symbol : Callgraph_t.fct = 
		  {
		    sign = fct.sign;
		    line = fct.line;
		    locallers = None;
		    locallees = None;
		    extcallers = None;
		    extcallees = None;
		    builtins = None;
		  }
		in
		defined_symbol
	    )
	    symbols
	)
  in
  let filtered_file_content : Callgraph_t.file =
    {
      file = full_file_content.file;
      path = full_file_content.path;
      defined = defined_symbols
    }
  in
  filtered_file_content

let rec parse_json_dir (dir:Callgraph_t.dir) (dirfullpath:string) : Callgraph_t.file list =

  let defined_symbols_files : Callgraph_t.file list =
    
    (match dir.files with
    | None -> []
    | Some files -> 
      List.map
	( fun f -> 

	  let jsoname_file : string = Printf.sprintf "%s/%s" dirfullpath f in
	  Printf.printf "Parse file: %s\n" jsoname_file;
	  Printf.printf "--------------------------------------------------------------------------------\n";

	  let json : Yojson.Basic.json = read_json_file jsoname_file in
	  let content : string = Yojson.Basic.to_string json in
	  Printf.printf "Read %s content is:\n %s: \n" f content;
	  let full_file_content : Callgraph_t.file = parse_json_file jsoname_file content in

	  (* Keep only symbols signatures and locations *)
	  let filtered_file_content : Callgraph_t.file = filter_file_content full_file_content in

	  Printf.printf "--------------------------------------------------------------------------------\n";
	  filtered_file_content
	)
	files
    )
  in

  let defined_symbols_dirs : (Callgraph_t.file list) list  = 

    (match dir.childrens with
    | None -> []
    | Some subdirs -> 
      List.map
	( fun (d:Callgraph_t.dir) -> 
	  let dirpath : string = Printf.sprintf "%s/%s" dirfullpath d.dir in
	  parse_json_dir d dirpath
	)
	subdirs
    )
  in

  let defined_symbols : Callgraph_t.file list = 
    
    List.fold_left
      ( fun s d -> 
	List.append s d
      )
      defined_symbols_files
      defined_symbols_dirs
  in
  defined_symbols

let list_defined_symbols (content:string) (dirfullpath:string) (output_json_filename:string) : unit =

  Printf.printf "atdgen parsed json directory is :\n";
  (* Use the atdgen JSON parser *)
  let dir : Callgraph_t.dir = Callgraph_j.dir_of_string content in
  print_endline (Callgraph_j.string_of_dir dir);

  (* Parse the json files contained in the current directory *)
  let defined_symbols_files : Callgraph_t.file list = parse_json_dir dir dirfullpath in

  (* Write the list of defined symbols to the JSON output file *)
  let defined_symbols : Callgraph_t.symbols =
    {
      application = None;
      defined_symbols = defined_symbols_files;
    }
  in
  
  (* Serialize the json file with atdgen. *)
  let jfile = Callgraph_j.string_of_symbols defined_symbols in
  Core.Std.Out_channel.write_all output_json_filename jfile;
  Printf.printf "Generated file: %s\n" output_json_filename

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("defined_symbols_jsonfile" %: string)
  +> anon ("dirname" %: string)
  +> anon (maybe("jsondirext" %: string))

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"This program generates a json file listing all the symbols defined in json file generated by the callers's analysis"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun defined_symbols_jsonfile dirfullpath jsondirext () -> 

	try
	  let dirname : string = Filename.basename dirfullpath
	  in
	  let jsoname_dir : string = 
	    (match jsondirext with
	    | None -> 
	      (
		let jsondirext = ".dir.callers.gen.json" in
		Printf.sprintf "%s/%s%s" dirfullpath dirname jsondirext
	      )
	    | Some dirext -> Printf.sprintf "%s/%s.%s" dirfullpath dirname dirext
	    )
	  in
	  let json : Yojson.Basic.json = read_json_file jsoname_dir in
	  let content : string = Yojson.Basic.to_string json in
	  Printf.printf "Start generation of defined symbols' json file from the json root directory...\nparsed content:\n %s: \n" content;
	  Printf.printf "--------------------------------------------------------------------------------\n";
	  list_defined_symbols content dirfullpath defined_symbols_jsonfile

	with
	| File_Not_Found -> raise Usage_Error
	| Unexpected_Json_File_Format -> raise Usage_Error
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -tag thread list_defined_symbols.native" *)
(* End: *)
