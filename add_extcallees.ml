(* Copyright @: Thales Communications & Security *)
(* Author: Hugues Balp *)
(* This file completes json files generated by Callers with "extcallee_defs" members *)

exception Internal_Error
(* exception Unexpected_Case *)
exception Usage_Error
exception File_Not_Found
exception Symbol_Not_Found
(* exception TBC *)
exception Unexpected_Error
(* exception Missing_File_Path *)

module Callers = Map.Make(String);;
module Callees = Map.Make(String);;

type callee = LocCallee of string | ExtCallee of Callgraph_t.extfct;;

class function_callees_json_parser (callee_json_filepath:string) = object(self)

  val callee_file_path : string = callee_json_filepath

  method read_json_file (filename:string) : Yojson.Basic.json =

    try
      Printf.printf "In_channel read file %s...\n" filename;
      (* Read JSON file into an OCaml string *)
      let buf = Core.Std.In_channel.read_all filename in
      (* Use the string JSON constructor *)
      let json1 = Yojson.Basic.from_string buf in
      json1
    with
      Sys_error _ -> 
	(
	  Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
	  Printf.printf "add_extcallees::ERROR::File_Not_Found::%s\n" filename;
	  let bname = Filename.basename filename in
	  (match bname with
	  | "defined_symbols.dir.callers.gen.json" ->
	    Printf.printf "You need first to list all the defined symbols by executing the list_json_files_in_dirs ocaml program\n"
	  | _ -> 
	    Printf.printf "You need first to generates all the json files by running the clang Callers's plugin\n"	    
	  );
	  Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
	  raise File_Not_Found
	)

  method search_symbol_in_directories (fct_sign:string) (dir:Callgraph_t.dir) (dirfullpath:string) : (string * int) option =

    Printf.printf "Parse dir: %s\n" dirfullpath;
    Printf.printf "================================================================================\n";

    let defined_symbols_filename : string = "defined_symbols.dir.callers.gen.json" in

    let defined_symbols_filepath : string = Printf.sprintf "%s/%s" dirfullpath defined_symbols_filename in

    Printf.printf "Read symbols defined in dir: %s\n" dirfullpath;

    let dir_symbols : Callgraph_t.dir_symbols = self#read_defined_symbols_in_dir defined_symbols_filepath in

    let searched_symbol : (string * int) option = self#search_symbol_in_dir fct_sign dir_symbols in
    
    (match searched_symbol with

    | None -> (* Not yet found symbol, so we look for it in childrens directories *)
      (
	Printf.printf "Not found symbol \"%s\" in directory \"%s\", so we look for it in childrens directories" fct_sign dirfullpath;
	
	let searched_symbol : (string * int) option = 
	  (match dir.childrens with
	  | None -> None
	  | Some subdirs -> 

	    let searched_symbols : (string * int) option list = 
	      List.map
		(
		  fun (d:Callgraph_t.dir) -> 
		    let dirpath : string = Printf.sprintf "%s/%s" dirfullpath d.dir in
		    let searched_symbol = self#search_symbol_in_directories fct_sign d dirpath in
		    searched_symbol
		)
		subdirs
	    in
	    let searched_symbol : (string * int) option = self#filter_found_symbol searched_symbols in
	    searched_symbol
	  )
	in
	searched_symbol
      )

    | Some found_symbol -> 
      (
	Printf.printf "FOUND symbol \"%s\" in directory \"%s\" !" fct_sign dirfullpath;
	searched_symbol
      )
    )

  (** Reads the symbols defined in input directory *)
  method read_defined_symbols_in_dir (defined_symbols_jsonfilepath:string) : Callgraph_t.dir_symbols =

    let json : Yojson.Basic.json = self#read_json_file defined_symbols_jsonfilepath in

    let content : string = Yojson.Basic.to_string json in
    Printf.printf "Reads the symbols defined in file \"%s\"\n" defined_symbols_jsonfilepath;
    (* Printf.printf "HBDBG parsed content:\n %s: \n" content; *)
    Printf.printf "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n";
      (* list_defined_symbols content rootdir_fullpath all_symbols_jsonfile application_name *)
    let dir_symbols : Callgraph_t.dir_symbols = Callgraph_j.dir_symbols_of_string content in
      (* print_endline (Callgraph_j.string_of_dir_symbols dir_symbols); *)
    dir_symbols

  (** Return the location of the function definition when defined in one of the analyzed directories *)
  method search_defined_symbol (fct_sign:string) (rootdir_fullpath:string) : (string * int) option =

    Printf.printf "Return the location of function \"%s\" when found within root directory: \"%s\"\n" fct_sign rootdir_fullpath;

    (* Parse the input directory tree json file *)
    (* Use the atdgen Yojson parser *)
    let jsondirext : string = "dir.callers.gen.json" in
    let rootdirname : string = Filename.basename rootdir_fullpath in
    let rootdir_jsoname : string = Printf.sprintf "%s/%s.%s" rootdir_fullpath rootdirname jsondirext in
    let rootdir_json : Yojson.Basic.json = self#read_json_file rootdir_jsoname in
    let rootdir_content : string = Yojson.Basic.to_string rootdir_json in
    let rootdir_tree : Callgraph_t.dir = Callgraph_j.dir_of_string rootdir_content in
    (* print_endline (Callgraph_j.string_of_dir rootdir_tree); *)

    (* Look for the symbol in all directories recursively. *)
    let found_symbol : (string * int) option = self#search_symbol_in_directories fct_sign rootdir_tree rootdir_fullpath in
    
    (match found_symbol with
    | None ->
      (
	Printf.printf "add_extcallees.ml::WARNING::Not found symbol \"%s\" in root directory \"%s\"\n" fct_sign rootdir_fullpath;
	Printf.printf "The input defined symbols json file is incomplete.\n";
	Printf.printf "The not found symbol is probably part of an external library.\n";
	(* raise Symbol_Not_Found; *)
	None
      )
    | Some (symb_def_file, symb_def_line) ->
      (
	Printf.printf "add_extcallees.ml: INFO::Found definition of function \"%s\" in \"%s:%d\"\n" fct_sign symb_def_file symb_def_line;
	found_symbol
      )
    )

  (** Return the location of the function definition when defined in the input directory symbols table *)
  method search_symbol_in_dir (fct_sign:string) (symbols:Callgraph_t.dir_symbols) : (string * int) option =

    Printf.printf "Search for the function's definition \"%s\" in directory \"%s\"...\n" fct_sign symbols.directory;
    (* print_endline (Callgraph_j.string_of_dir_symbols symbols); *)
    
    (* Look for the callee function among all functions defined in the json file *)
    let searched_symbols : (string * int) option list =
      List.map
      (
	fun (file : Callgraph_t.file) -> 
	  (* Check whether the function is the searched one *)
	  let searched_symbol_def : (string * int) option = 
	    try
	      (
		let searched_symbol : Callgraph_t.fct option = 
		  (
		    match file.defined with
		    | None -> None
		    | Some symbols ->
		      Some (
			List.find
			  (
			    fun (fct : Callgraph_t.fct) -> String.compare fct.sign fct_sign == 0
			  )
			  symbols
		      )
		  )
		in
		(match searched_symbol with
		| None -> None
		| Some found_symbol ->
		  (
		    (* Get the function definition location *)
		    let symb_def_file : string = Printf.sprintf "%s/%s/%s" symbols.path symbols.directory file.file in
		    Some (symb_def_file, found_symbol.line)
		  )
		)
	      )
	    with
	      Not_found -> None
	  in
	  searched_symbol_def
      )
	symbols.file_symbols
    in
    self#filter_found_symbol searched_symbols

  method filter_found_symbol (searched_symbols : (string * int) option list) : (string * int) option =

    let searched_symbol : (string * int) option =
      try
	List.find
	  (
	    fun result ->
	      (* Check whether the function is the searched one *)
  	      (match result with
	      | None -> false
	      | Some _ -> true
	      )
	  )
	  searched_symbols
      with
	Not_found -> None
    in
    searched_symbol
      
  method print_edited_file (edited_file:Callgraph_t.file) (json_filename:string) =

    let jfile = Callgraph_j.string_of_file edited_file in
    (* print_endline jfile; *)
    (* Write the new_file serialized by atdgen to a JSON file *)
    (* let new_jsonfilepath:string = Printf.sprintf "%s.new.json" json_filename in *)
    (* Core.Std.Out_channel.write_all new_jsonfilepath jfile *)
    Core.Std.Out_channel.write_all json_filename jfile

  method parse_caller_file (json_filepath:string) (rootdir_fullpath:string): Callgraph_t.file =

    (* Use the atdgen Yojson parser *)
    let dirpath : string = Common.read_before_last '/' json_filepath in
    let filename : string = Common.read_after_last '/' 1 json_filepath in
    let jsoname_file = String.concat "" [ dirpath; "/"; filename; ".file.callers.gen.json" ] in
    let json : Yojson.Basic.json = self#read_json_file jsoname_file in
    let content : string = Yojson.Basic.to_string json in
    (* Printf.printf "Read caller file \"%s\" content is:\n %s: \n" filename content; *)
    (* Printf.printf "atdgen parsed json file is :\n"; *)
    let file : Callgraph_t.file = Callgraph_j.file_of_string content in
    (* print_endline (Callgraph_j.string_of_file file); *)
    
    (* Parse the json functions contained in the current file *)
    let edited_functions:Callgraph_t.fct list =

      (match file.defined with
      | None -> []
      | Some fcts ->
	(
	  (* Parses all defined function *)
	  let edited_functions : Callgraph_t.fct list =

	    List.map
  	      (
  		fun (fct:Callgraph_t.fct) -> 
		  (
		    (* For each external callee, check where it is really defined. *)
		    (* If its definition is in fact located in the caller file, *)
	            (* then replace this external callee function by a local one. *)
		    (match fct.extcallees with
		    | None -> fct
		    | Some extcallees ->
		      (
			Printf.printf "Try to edit external callees of function \"%s\" declared in caller file \"%s\"...\n" fct.sign file.file;

			let edited_extcallees : callee list =

			  List.map
			    ( 
			      fun (f:Callgraph_t.extfct) -> 
				(
				  (* Check whether the extcallee definition does already exists or not *)
				  let edited_callee : callee =

				    (match f.def with
				    | "unknownExtFctDef" ->
				      (
					  (* Location of extcallee linked definition is not yet known. *)
					Printf.printf "Not found definition of extcallee: sign=\"%s\", decl=%s, def=?\n" f.sign f.decl;
					
					(Printf.printf "Try to look for symbol \"%s\" in the root directory \"%s\"...\n" f.sign rootdir_fullpath;
					 let search_result : (string * int) option = self#search_defined_symbol f.sign rootdir_fullpath
					 in
					 (match search_result with
					 | Some (def_file, def_line) -> 
					   (
					       (* Check whether the definition is local to the caller file or external. *)
					       (* Printf.printf "add_extcallees.ml::INFO::Check whether the definition is local to the caller file or external.\n"; *)
					       (* Printf.printf "symb_def_file: %s\n" def_file; *)
					       (* Printf.printf "caller_file: %s\n" json_filepath; *)
					     if String.compare def_file json_filepath == 0 then
					       (
						 Printf.printf "add_extcallees.ml::INFO::the extcallee definition is local to the caller file, so replace it by a locallee !\n";
						 let new_locallee : callee = LocCallee f.sign in
						 Printf.printf "REPLACED extcallee by locallee: sign=\"%s\", line=%d\n" f.sign def_line;
						 new_locallee
					       )
					     else
					       (
						 Printf.printf "add_extcallees.ml::INFO::the extcallee definition is extern to the caller file, so edit its definition...\n";
						 let extcallee_def : string = Printf.sprintf "%s:%d" def_file def_line
						 in
						 let (edited_extcallee : callee) = ExtCallee
						   {
		      				     sign = f.sign;
		      				     decl = f.decl;
		      				     def = extcallee_def;
						   }
						 in
						 Printf.printf "EDITED extcallee: sign=\"%s\", decl=%s, def=%s\n" f.sign f.decl extcallee_def;
						 edited_extcallee
					       )
					   )
					 | None -> 
					   (
					     Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
					     Printf.printf "add_extcallees.ml::WARNING::Not found symbol \"%s\" in root directory \"%s\"\n" f.sign rootdir_fullpath;
					     Printf.printf "The input defined symbols json file is incomplete.\n";
					     Printf.printf "The not found symbol is probably part of an external library.\n";
					     Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
					     (* raise Symbol_Not_Found *)
						 
					     (* Keep the input excallee unchanged *)
					     let (edited_extcallee : callee) = ExtCallee
					       {
		      				 sign = f.sign;
		      				 decl = f.decl;
		      				 def = "unlinkedExtCaller";
					       }
					     in
					     Printf.printf "NOT_FOUND extcallee: sign=\"%s\", decl=%s, def=%s\n" f.sign f.decl f.def;
					     edited_extcallee
					   )
					 )
					)
				      )
				    | _ -> ExtCallee f
				    )
				  in
				  edited_callee
				)
			    )
			    extcallees
			in
			let external_callees : callee list = 
			  List.filter
			    (
			      fun callee -> 
				match callee with
				| LocCallee _ -> false
				| ExtCallee _ -> true
			    )
			    edited_extcallees
			in
			let new_local_callees : callee list = 
			  List.filter
			    (
			      fun callee -> 
				match callee with
				| LocCallee _ -> true
				| ExtCallee _ -> false
			    )
			    edited_extcallees
			in
			let extcallees : Callgraph_t.extfct list option =
			  (
			    match external_callees with
			    | [] -> None
			    | _ -> 
			      Some 
				(
				  List.map
				    (fun extcallee -> 
				      match extcallee with
				      | LocCallee _ -> raise Internal_Error
				      | ExtCallee extc -> extc
				    )
				    external_callees
				)
			  )
			in
			let locallees : string list option =
			  (
			    fct.locallees;
			    match new_local_callees with
			    | [] -> fct.locallees
			    | _ -> 
			      (
				let new_locallees : string list =
				  List.map
				    (fun locallee -> 
				      match locallee with
				      | LocCallee lc -> lc
				      | ExtCallee _ -> raise Internal_Error
				    )
				    new_local_callees
				in
				let locallees : string list =
				  (match fct.locallees with
				  | None -> new_locallees
				  | Some locallees -> 
				    List.append locallees new_locallees)
				in
				Some locallees
			      )
			  )
			in
			let edited_function : Callgraph_t.fct =
			  {
  			    sign = fct.sign;
  			    line = fct.line;
  			    locallers = fct.locallers;
  			    locallees = locallees;
  			    extcallees = extcallees;
  			    extcallers = fct.extcallers;
			    builtins = fct.builtins;
			  }
			in
			edited_function
		      )
		    )
		  )
	      )
	      fcts
	  in
	  edited_functions
	)
      )
    in

    let edited_file : Callgraph_t.file = 
      {
	file = file.file;
	path = file.path;
	defined = Some edited_functions;
      }
    in
    edited_file

end

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("file_json" %: string)
  +> anon ("rootdir_fullpath" %: string)

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"Completes external callee's funcion definitions in callers's generated json files"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun file_json rootdir_fullpath () -> 
	try
	  (
	    let parser = new function_callees_json_parser file_json in
	    let edited_file = parser#parse_caller_file file_json rootdir_fullpath in

	    (* let jsoname_file = String.concat "." [ file_json; "edited.debug.json" ] in *)
	    let jsoname_file = String.concat "" [ file_json; ".file.callers.gen.json" ] in
	    parser#print_edited_file edited_file jsoname_file
	  )
	with
	| File_Not_Found _ -> raise Usage_Error
	| _ ->
	  (
	    Printf.printf "add_extcallees::ERROR::unexpected error\n";
	    raise Unexpected_Error
	  )
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -tag thread add_extcallees.native" *)
(* End: *)
